// Estado de la aplicaci√≥n
let state = {
    workSchedule: {
        start: '08:00',
        end: '17:30'
    },
    locations: {
        home: {
            address: '',
            lat: null,
            lng: null
        },
        work: {
            address: '',
            lat: null,
            lng: null
        },
        commute: {
            homeToWork: null,
            workToHome: null
        }
    },
    tasks: [],
    currentWeekStart: new Date()
};

// Inicializaci√≥n
document.addEventListener('DOMContentLoaded', () => {
    loadFromStorage();
    initializeWeek();
    setupEventListeners();
    updateScheduleInfo();
    updateLocationInfo();
    renderCalendar();
    renderTasks();
    generateSuggestions();
});

// Event Listeners
function setupEventListeners() {
    // Ubicaciones
    document.getElementById('detectHome').addEventListener('click', () => detectLocation('home'));
    document.getElementById('detectWork').addEventListener('click', () => detectLocation('work'));
    document.getElementById('calculateCommute').addEventListener('click', calculateCommuteTime);
    document.getElementById('saveLocations').addEventListener('click', saveLocations);

    // Horario
    document.getElementById('saveWorkSchedule').addEventListener('click', saveWorkSchedule);

    // Tareas
    document.getElementById('taskForm').addEventListener('submit', addTask);

    // Calendario
    document.getElementById('prevWeek').addEventListener('click', () => navigateWeek(-1));
    document.getElementById('nextWeek').addEventListener('click', () => navigateWeek(1));

    // Autocompletado de direcciones
    setupAddressAutocomplete('homeAddress', 'homeAddressSuggestions', 'home');
    setupAddressAutocomplete('workAddress', 'workAddressSuggestions', 'work');
    setupAddressAutocomplete('taskAddress', 'taskAddressSuggestions', 'task');

    // Modal de ayuda
    setupHelpModal();
}

// ===== MODAL DE AYUDA =====
function setupHelpModal() {
    const modal = document.getElementById('helpModal');
    const btn = document.getElementById('helpButton');
    const closeBtn = document.getElementsByClassName('close')[0];

    // Abrir modal
    btn.addEventListener('click', () => {
        modal.classList.add('show');
    });

    // Cerrar con X
    closeBtn.addEventListener('click', () => {
        modal.classList.remove('show');
    });

    // Cerrar al hacer clic fuera del modal
    window.addEventListener('click', (event) => {
        if (event.target === modal) {
            modal.classList.remove('show');
        }
    });

    // Cerrar con tecla Escape
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && modal.classList.contains('show')) {
            modal.classList.remove('show');
        }
    });
}

// ===== FUNCIONES DE AUTOCOMPLETADO =====

let autocompleteTimers = {};
let selectedSuggestionIndex = {};

function setupAddressAutocomplete(inputId, suggestionsId, type) {
    const input = document.getElementById(inputId);
    const suggestionsContainer = document.getElementById(suggestionsId);

    if (!input || !suggestionsContainer) return;

    selectedSuggestionIndex[inputId] = -1;

    // Evento de escritura
    input.addEventListener('input', (e) => {
        const query = e.target.value.trim();

        if (query.length < 3) {
            hideSuggestions(suggestionsId);
            return;
        }

        // Debounce: esperar 500ms despu√©s de que el usuario deje de escribir
        clearTimeout(autocompleteTimers[inputId]);
        autocompleteTimers[inputId] = setTimeout(() => {
            searchAddresses(query, suggestionsId, inputId, type);
        }, 500);
    });

    // Navegaci√≥n con teclado
    input.addEventListener('keydown', (e) => {
        const suggestions = suggestionsContainer.querySelectorAll('.autocomplete-suggestion-item');

        if (suggestions.length === 0) return;

        if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectedSuggestionIndex[inputId] = Math.min(
                selectedSuggestionIndex[inputId] + 1,
                suggestions.length - 1
            );
            updateSelectedSuggestion(suggestionsId, inputId);
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectedSuggestionIndex[inputId] = Math.max(
                selectedSuggestionIndex[inputId] - 1,
                0
            );
            updateSelectedSuggestion(suggestionsId, inputId);
        } else if (e.key === 'Enter') {
            e.preventDefault();
            if (selectedSuggestionIndex[inputId] >= 0) {
                suggestions[selectedSuggestionIndex[inputId]].click();
            }
        } else if (e.key === 'Escape') {
            hideSuggestions(suggestionsId);
        }
    });

    // Cerrar al hacer clic fuera
    document.addEventListener('click', (e) => {
        if (!input.contains(e.target) && !suggestionsContainer.contains(e.target)) {
            hideSuggestions(suggestionsId);
        }
    });
}

async function searchAddresses(query, suggestionsId, inputId, type) {
    const suggestionsContainer = document.getElementById(suggestionsId);

    // Mostrar indicador de carga
    suggestionsContainer.innerHTML = '<div class="autocomplete-loading">üîç Buscando direcciones...</div>';
    suggestionsContainer.classList.add('active');

    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&limit=5&addressdetails=1`,
            {
                headers: {
                    'User-Agent': 'CalendarioInteligente/1.0'
                }
            }
        );

        const data = await response.json();

        if (data && data.length > 0) {
            displaySuggestions(data, suggestionsId, inputId, type);
        } else {
            suggestionsContainer.innerHTML = '<div class="autocomplete-no-results">No se encontraron direcciones</div>';
        }
    } catch (error) {
        console.error('Error buscando direcciones:', error);
        suggestionsContainer.innerHTML = '<div class="autocomplete-no-results">Error al buscar direcciones</div>';
    }
}

function displaySuggestions(suggestions, suggestionsId, inputId, type) {
    const container = document.getElementById(suggestionsId);
    selectedSuggestionIndex[inputId] = -1;

    container.innerHTML = suggestions.map((suggestion, index) => {
        const address = suggestion.display_name;
        const parts = address.split(',');
        const main = parts.slice(0, 2).join(',');
        const detail = parts.slice(2).join(',');

        return `
            <div class="autocomplete-suggestion-item" data-index="${index}" data-lat="${suggestion.lat}" data-lng="${suggestion.lon}" data-address="${address}">
                <div class="suggestion-main">${main}</div>
                ${detail ? `<div class="suggestion-detail">${detail}</div>` : ''}
            </div>
        `;
    }).join('');

    container.classList.add('active');

    // Agregar eventos de clic
    container.querySelectorAll('.autocomplete-suggestion-item').forEach(item => {
        item.addEventListener('click', () => {
            selectSuggestion(item, inputId, type);
        });

        item.addEventListener('mouseenter', () => {
            selectedSuggestionIndex[inputId] = parseInt(item.dataset.index);
            updateSelectedSuggestion(suggestionsId, inputId);
        });
    });
}

function selectSuggestion(item, inputId, type) {
    const input = document.getElementById(inputId);
    const address = item.dataset.address;
    const lat = parseFloat(item.dataset.lat);
    const lng = parseFloat(item.dataset.lng);

    input.value = address;

    // Guardar coordenadas seg√∫n el tipo
    if (type === 'home' || type === 'work') {
        state.locations[type].address = address;
        state.locations[type].lat = lat;
        state.locations[type].lng = lng;
        updateLocationDisplay(type);
        saveToStorage();
    }

    hideSuggestions(inputId + 'Suggestions');
}

function updateSelectedSuggestion(suggestionsId, inputId) {
    const container = document.getElementById(suggestionsId);
    const items = container.querySelectorAll('.autocomplete-suggestion-item');

    items.forEach((item, index) => {
        if (index === selectedSuggestionIndex[inputId]) {
            item.classList.add('selected');
            item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
            item.classList.remove('selected');
        }
    });
}

function hideSuggestions(suggestionsId) {
    const container = document.getElementById(suggestionsId);
    if (container) {
        container.classList.remove('active');
        container.innerHTML = '';
    }
}

// ===== FUNCIONES DE GEOLOCALIZACI√ìN =====

// Detectar ubicaci√≥n actual
function detectLocation(type) {
    if (!navigator.geolocation) {
        alert('Tu navegador no soporta geolocalizaci√≥n');
        return;
    }

    const button = document.getElementById(type === 'home' ? 'detectHome' : 'detectWork');
    button.disabled = true;
    button.textContent = 'üìç Detectando...';

    navigator.geolocation.getCurrentPosition(
        (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;

            state.locations[type].lat = lat;
            state.locations[type].lng = lng;

            // Usar geocodificaci√≥n inversa para obtener direcci√≥n
            reverseGeocode(lat, lng, type);

            button.disabled = false;
            button.textContent = '‚úÖ Ubicaci√≥n detectada';

            setTimeout(() => {
                button.textContent = 'üìç Detectar mi ubicaci√≥n actual';
            }, 3000);

            updateLocationDisplay(type);
            saveToStorage();
        },
        (error) => {
            alert('Error al detectar ubicaci√≥n: ' + error.message);
            button.disabled = false;
            button.textContent = 'üìç Detectar mi ubicaci√≥n actual';
        },
        {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
        }
    );
}

// Geocodificaci√≥n inversa (coordenadas a direcci√≥n)
async function reverseGeocode(lat, lng, type) {
    try {
        // Usar la API gratuita de Nominatim (OpenStreetMap)
        const response = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`,
            {
                headers: {
                    'User-Agent': 'CalendarioInteligente/1.0'
                }
            }
        );

        const data = await response.json();

        if (data && data.display_name) {
            state.locations[type].address = data.display_name;
            document.getElementById(type === 'home' ? 'homeAddress' : 'workAddress').value = data.display_name;
        }

        updateLocationDisplay(type);
        saveToStorage();
    } catch (error) {
        console.error('Error en geocodificaci√≥n inversa:', error);
    }
}

// Geocodificaci√≥n directa (direcci√≥n a coordenadas)
async function geocodeAddress(address, type) {
    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`,
            {
                headers: {
                    'User-Agent': 'CalendarioInteligente/1.0'
                }
            }
        );

        const data = await response.json();

        if (data && data.length > 0) {
            state.locations[type].lat = parseFloat(data[0].lat);
            state.locations[type].lng = parseFloat(data[0].lon);
            state.locations[type].address = address;

            updateLocationDisplay(type);
            return true;
        }
        return false;
    } catch (error) {
        console.error('Error en geocodificaci√≥n:', error);
        return false;
    }
}

// Actualizar display de ubicaci√≥n
function updateLocationDisplay(type) {
    const coordsDiv = document.getElementById(type === 'home' ? 'homeCoords' : 'workCoords');
    const location = state.locations[type];

    if (location.lat && location.lng) {
        coordsDiv.innerHTML = `
            üìç Coordenadas: ${location.lat.toFixed(6)}, ${location.lng.toFixed(6)}<br>
            <a href="https://www.google.com/maps?q=${location.lat},${location.lng}" target="_blank" style="color: #667eea;">
                Ver en Google Maps
            </a>
        `;
    } else {
        coordsDiv.innerHTML = '';
    }
}

// Calcular tiempo de traslado autom√°ticamente
async function calculateCommuteTime() {
    const home = state.locations.home;
    const work = state.locations.work;

    if (!home.lat || !home.lng || !work.lat || !work.lng) {
        alert('Primero debes configurar las ubicaciones de casa y trabajo');
        return;
    }

    const button = document.getElementById('calculateCommute');
    button.disabled = true;
    button.textContent = 'üöó Calculando...';

    try {
        // Usar OSRM (Open Source Routing Machine) - API gratuita
        const response = await fetch(
            `https://router.project-osrm.org/route/v1/driving/${home.lng},${home.lat};${work.lng},${work.lat}?overview=false`
        );

        const data = await response.json();

        if (data.code === 'Ok' && data.routes && data.routes.length > 0) {
            const durationSeconds = data.routes[0].duration;
            const durationMinutes = Math.ceil(durationSeconds / 60);

            state.locations.commute.homeToWork = durationMinutes;
            state.locations.commute.workToHome = durationMinutes + 5; // A√±adir 5 min por tr√°fico

            document.getElementById('homeToWork').value = durationMinutes;
            document.getElementById('workToHome').value = durationMinutes + 5;

            saveToStorage();
            updateLocationInfo();

            showNotification(`Tiempo calculado: ${durationMinutes} minutos aproximadamente`, 'success');
        } else {
            throw new Error('No se pudo calcular la ruta');
        }
    } catch (error) {
        console.error('Error calculando tiempo de traslado:', error);
        alert('No se pudo calcular autom√°ticamente. Por favor, ingresa los tiempos manualmente.');
    } finally {
        button.disabled = false;
        button.textContent = 'üöó Calcular autom√°ticamente';
    }
}

// Calcular distancia entre dos puntos (f√≥rmula de Haversine)
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 6371; // Radio de la Tierra en km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;

    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng / 2) * Math.sin(dLng / 2);

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;

    return distance; // en kil√≥metros
}

// Estimar tiempo de traslado basado en distancia (si no hay coordenadas exactas)
function estimateTravelTime(distance) {
    // Asumir velocidad promedio de 30 km/h en ciudad
    const avgSpeed = 30;
    const timeHours = distance / avgSpeed;
    const timeMinutes = Math.ceil(timeHours * 60);
    return timeMinutes;
}

// Guardar ubicaciones
async function saveLocations() {
    // Guardar direcciones
    const homeAddress = document.getElementById('homeAddress').value;
    const workAddress = document.getElementById('workAddress').value;
    const homeToWork = parseInt(document.getElementById('homeToWork').value) || null;
    const workToHome = parseInt(document.getElementById('workToHome').value) || null;

    // Si hay direcciones pero no coordenadas, geocodificar
    if (homeAddress && !state.locations.home.lat) {
        await geocodeAddress(homeAddress, 'home');
    }

    if (workAddress && !state.locations.work.lat) {
        await geocodeAddress(workAddress, 'work');
    }

    // Actualizar direcciones si fueron modificadas manualmente
    if (homeAddress) state.locations.home.address = homeAddress;
    if (workAddress) state.locations.work.address = workAddress;

    // Guardar tiempos de traslado
    state.locations.commute.homeToWork = homeToWork;
    state.locations.commute.workToHome = workToHome;

    saveToStorage();
    updateLocationInfo();
    generateSuggestions(); // Regenerar sugerencias con nueva informaci√≥n

    showNotification('Ubicaciones guardadas correctamente', 'success');
}

// Actualizar informaci√≥n de ubicaciones
function updateLocationInfo() {
    const infoBox = document.getElementById('locationInfo');
    const { home, work, commute } = state.locations;

    let html = '<strong>Configuraci√≥n actual:</strong><br>';

    if (home.address) {
        html += `üè† Casa: ${home.address.substring(0, 60)}...<br>`;
    }

    if (work.address) {
        html += `üíº Trabajo: ${work.address.substring(0, 60)}...<br>`;
    }

    if (commute.homeToWork || commute.workToHome) {
        html += `<br><strong>Tiempos de traslado:</strong><br>`;
        if (commute.homeToWork) html += `Casa ‚Üí Trabajo: ${commute.homeToWork} minutos<br>`;
        if (commute.workToHome) html += `Trabajo ‚Üí Casa: ${commute.workToHome} minutos<br>`;
    }

    if (home.lat && work.lat) {
        const distance = calculateDistance(home.lat, home.lng, work.lat, work.lng);
        html += `üìè Distancia: ${distance.toFixed(2)} km<br>`;
    }

    infoBox.innerHTML = html || 'No hay ubicaciones configuradas';
}

// ===== FUNCIONES DE HORARIO Y TAREAS (Actualizadas) =====

// Guardar horario laboral
function saveWorkSchedule() {
    const start = document.getElementById('workStart').value;
    const end = document.getElementById('workEnd').value;

    state.workSchedule = { start, end };
    saveToStorage();
    updateScheduleInfo();
    renderCalendar();

    showNotification('Horario laboral guardado correctamente', 'success');
}

function updateScheduleInfo() {
    const { start, end } = state.workSchedule;
    const infoBox = document.getElementById('scheduleInfo');

    const startTime = parseTime(start);
    const endTime = parseTime(end);
    const workHours = (endTime - startTime) / 60;
    const freeHoursBefore = startTime / 60;
    const freeHoursAfter = (24 * 60 - endTime) / 60;

    let html = `
        <strong>Horario configurado:</strong><br>
        Trabajo: ${start} - ${end} (${workHours.toFixed(2)} horas)<br>
        Tiempo libre: Antes ${freeHoursBefore.toFixed(2)}h | Despu√©s ${freeHoursAfter.toFixed(2)}h
    `;

    // A√±adir informaci√≥n de traslados si est√° disponible
    const commute = state.locations.commute;
    if (commute.homeToWork || commute.workToHome) {
        html += `<br><br><strong>Considerando traslados:</strong><br>`;
        if (commute.homeToWork) {
            const arrivalTime = formatMinutesToTime(startTime - commute.homeToWork);
            html += `Salir de casa a las ${arrivalTime} para llegar a tiempo<br>`;
        }
        if (commute.workToHome) {
            const homeArrival = formatMinutesToTime(endTime + commute.workToHome);
            html += `Llegada estimada a casa: ${homeArrival}<br>`;
        }
    }

    infoBox.innerHTML = html;
}

// A√±adir tarea (actualizado con direcci√≥n y ventanas de tiempo)
function addTask(e) {
    e.preventDefault();

    // Obtener y validar deadline
    const deadlineInput = document.getElementById('taskDeadline').value;
    let deadline = null;
    if (deadlineInput) {
        deadline = parseDateInput(deadlineInput);
        if (!deadline) {
            alert('Formato de fecha l√≠mite inv√°lido. Usa DD-MM-YYYY (ej: 15-10-2025)');
            return;
        }
    }

    // Obtener y validar ventana de tiempo
    const windowStartInput = document.getElementById('taskWindowStart').value;
    const windowEndInput = document.getElementById('taskWindowEnd').value;
    let windowStart = null;
    let windowEnd = null;

    if (windowStartInput || windowEndInput) {
        if (windowStartInput && windowEndInput) {
            windowStart = parseDateInput(windowStartInput);
            windowEnd = parseDateInput(windowEndInput);

            if (!windowStart || !windowEnd) {
                alert('Formato de ventana de tiempo inv√°lido. Usa DD-MM-YYYY');
                return;
            }

            // Validar que windowStart < windowEnd
            if (new Date(windowStart) > new Date(windowEnd)) {
                alert('La fecha de inicio debe ser anterior a la fecha de fin');
                return;
            }
        } else {
            alert('Debes especificar tanto fecha de inicio como de fin para la ventana de tiempo');
            return;
        }
    }

    const task = {
        id: Date.now(),
        name: document.getElementById('taskName').value,
        duration: parseFloat(document.getElementById('taskDuration').value),
        location: document.getElementById('taskLocation').value,
        address: document.getElementById('taskAddress').value || null,
        priority: document.getElementById('taskPriority').value,
        deadline: deadline,
        windowStart: windowStart,
        windowEnd: windowEnd,
        assignedDate: null,
        assignedTime: null,
        lat: null,
        lng: null
    };

    // Intentar geocodificar la direcci√≥n si se proporcion√≥
    if (task.address) {
        geocodeTaskAddress(task);
    }

    state.tasks.push(task);
    saveToStorage();

    document.getElementById('taskForm').reset();
    document.getElementById('taskPriority').value = 'media';

    renderCalendar();
    renderTasks();
    generateSuggestions();

    showNotification('Tarea a√±adida correctamente', 'success');
}

// Geocodificar direcci√≥n de tarea
async function geocodeTaskAddress(task) {
    try {
        const response = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(task.address)}&limit=1`,
            {
                headers: {
                    'User-Agent': 'CalendarioInteligente/1.0'
                }
            }
        );

        const data = await response.json();

        if (data && data.length > 0) {
            task.lat = parseFloat(data[0].lat);
            task.lng = parseFloat(data[0].lon);
            saveToStorage();
        }
    } catch (error) {
        console.error('Error geocodificando tarea:', error);
    }
}

// Eliminar tarea
function deleteTask(taskId) {
    if (confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
        state.tasks = state.tasks.filter(t => t.id !== taskId);
        saveToStorage();
        renderCalendar();
        renderTasks();
        generateSuggestions();
        showNotification('Tarea eliminada', 'success');
    }
}

// Asignar tarea a un d√≠a espec√≠fico
function assignTask(taskId, dateStr) {
    const task = state.tasks.find(t => t.id === taskId);
    if (!task) return;

    const date = new Date(dateStr);
    const assignedTime = calculateBestTimeSlot(date, task.duration, task);

    task.assignedDate = dateStr;
    task.assignedTime = assignedTime;

    saveToStorage();
    renderCalendar();
    renderTasks();
    generateSuggestions();

    showNotification(`Tarea asignada a ${formatDate(date)}`, 'success');
}

// Desasignar tarea
function unassignTask(taskId) {
    const task = state.tasks.find(t => t.id === taskId);
    if (!task) return;

    task.assignedDate = null;
    task.assignedTime = null;

    saveToStorage();
    renderCalendar();
    renderTasks();
    generateSuggestions();

    showNotification('Tarea desasignada', 'success');
}

// Calcular mejor franja horaria disponible (mejorado con ubicaciones)
function calculateBestTimeSlot(date, duration, task = null) {
    const { start, end } = state.workSchedule;
    const workStart = parseTime(start);
    const workEnd = parseTime(end);
    const commute = state.locations.commute;

    // Preferir despu√©s del trabajo
    let afterWorkStart = workEnd;

    // Si tenemos tiempo de traslado trabajo->casa, a√±adirlo
    if (commute.workToHome) {
        afterWorkStart += commute.workToHome;
    }

    const dayEnd = 22 * 60; // Hasta las 10 PM

    if (afterWorkStart + duration * 60 <= dayEnd) {
        return formatMinutesToTime(afterWorkStart);
    }

    // Si no cabe despu√©s, intentar antes del trabajo
    let dayStart = 7 * 60; // Desde las 7 AM

    // Si tenemos tiempo de traslado casa->trabajo, considerarlo
    if (commute.homeToWork) {
        const minimumStart = workStart - commute.homeToWork - duration * 60;
        if (minimumStart >= dayStart) {
            return formatMinutesToTime(minimumStart);
        }
    }

    // Por defecto, justo despu√©s del trabajo
    return formatMinutesToTime(workEnd);
}

// Motor de sugerencias inteligentes (mejorado con ubicaciones)
function generateSuggestions() {
    const unassignedTasks = state.tasks.filter(t => !t.assignedDate);

    if (unassignedTasks.length === 0) {
        document.getElementById('suggestions').innerHTML = '<div class="empty-state">No hay tareas pendientes de asignar</div>';
        return;
    }

    const suggestions = [];

    // Agrupar tareas por proximidad geogr√°fica (si tienen coordenadas)
    const tasksWithCoords = unassignedTasks.filter(t => t.lat && t.lng);
    if (tasksWithCoords.length > 1) {
        const proximityGroups = groupTasksByProximity(tasksWithCoords);

        proximityGroups.forEach(group => {
            if (group.length > 1) {
                const totalDuration = group.reduce((sum, t) => sum + t.duration, 0);
                const suggestedDay = findBestDayForTasks(group, totalDuration);

                suggestions.push({
                    type: 'proximity',
                    tasks: group,
                    day: suggestedDay,
                    reason: `Estas tareas est√°n muy cerca una de otra (menos de 2km). Puedes ahorrar ${estimateTimeSaved(group)} minutos haci√©ndolas el mismo d√≠a.`,
                    totalDuration
                });
            }
        });
    }

    // Agrupar tareas por ubicaci√≥n similar (nombre)
    const locationGroups = groupTasksByLocation(unassignedTasks);

    Object.entries(locationGroups).forEach(([locationKey, tasks]) => {
        if (tasks.length > 1) {
            const totalDuration = tasks.reduce((sum, t) => sum + t.duration, 0);
            const suggestedDay = findBestDayForTasks(tasks, totalDuration);

            suggestions.push({
                type: 'location-group',
                tasks: tasks,
                day: suggestedDay,
                reason: `Estas tareas est√°n en ubicaciones similares (${tasks[0].location}). Puedes ahorrar tiempo haci√©ndolas el mismo d√≠a.`,
                totalDuration
            });
        }
    });

    // Sugerencias para tareas urgentes
    unassignedTasks
        .filter(t => t.priority === 'urgente')
        .forEach(task => {
            const suggestedDay = findBestDayForTasks([task], task.duration);
            suggestions.push({
                type: 'urgent',
                tasks: [task],
                day: suggestedDay,
                reason: 'Esta tarea es urgente y deber√≠a hacerse lo antes posible.',
                totalDuration: task.duration
            });
        });

    // Sugerencias para tareas con fecha l√≠mite
    unassignedTasks
        .filter(t => t.deadline)
        .forEach(task => {
            const deadline = new Date(task.deadline);
            const today = new Date();
            const daysUntilDeadline = Math.ceil((deadline - today) / (1000 * 60 * 60 * 24));

            if (daysUntilDeadline <= 7) {
                suggestions.push({
                    type: 'deadline',
                    tasks: [task],
                    day: task.deadline,
                    reason: `Esta tarea tiene fecha l√≠mite el ${formatDate(deadline)} (en ${daysUntilDeadline} d√≠as).`,
                    totalDuration: task.duration
                });
            }
        });

    // Ordenar sugerencias por prioridad
    suggestions.sort((a, b) => {
        const priorityOrder = { urgent: 0, deadline: 1, proximity: 2, 'location-group': 3 };
        return priorityOrder[a.type] - priorityOrder[b.type];
    });

    renderSuggestions(suggestions);
}

// Agrupar tareas por proximidad geogr√°fica
function groupTasksByProximity(tasks) {
    const groups = [];
    const used = new Set();
    const proximityThreshold = 2; // 2 km

    tasks.forEach((task, i) => {
        if (used.has(i)) return;

        const group = [task];
        used.add(i);

        tasks.forEach((otherTask, j) => {
            if (i !== j && !used.has(j)) {
                const distance = calculateDistance(
                    task.lat, task.lng,
                    otherTask.lat, otherTask.lng
                );

                if (distance <= proximityThreshold) {
                    group.push(otherTask);
                    used.add(j);
                }
            }
        });

        if (group.length > 0) {
            groups.push(group);
        }
    });

    return groups;
}

// Estimar tiempo ahorrado agrupando tareas
function estimateTimeSaved(tasks) {
    // Asumir 15 minutos de traslado ahorrado por cada tarea adicional
    return (tasks.length - 1) * 15;
}

// Agrupar tareas por ubicaci√≥n similar (texto)
function groupTasksByLocation(tasks) {
    const groups = {};

    tasks.forEach(task => {
        const normalizedLocation = task.location
            .toLowerCase()
            .replace(/\d+/g, '')
            .replace(/\b(calle|avenida|av|n√∫mero|centro|local)\b/g, '')
            .trim();

        const key = normalizedLocation.split(' ').slice(0, 2).join(' ');

        if (!groups[key]) {
            groups[key] = [];
        }
        groups[key].push(task);
    });

    return groups;
}

// Encontrar mejor d√≠a para tareas (mejorado con ventanas de tiempo)
function findBestDayForTasks(tasks, totalDuration) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const { start, end } = state.workSchedule;
    const workStart = parseTime(start);
    const workEnd = parseTime(end);
    const commute = state.locations.commute;

    const dayStart = 7 * 60;
    const dayEnd = 22 * 60;

    // Calcular tiempo disponible considerando traslados
    let availableTimePerDay = (dayEnd - dayStart) - (workEnd - workStart);
    if (commute.homeToWork) availableTimePerDay -= commute.homeToWork;
    if (commute.workToHome) availableTimePerDay -= commute.workToHome;

    const availableHours = availableTimePerDay / 60;

    // Determinar rango de fechas v√°lido considerando ventanas de tiempo
    let searchStart = new Date(state.currentWeekStart);
    let searchEnd = new Date(state.currentWeekStart);
    searchEnd.setDate(searchEnd.getDate() + 13); // 2 semanas

    // Si hay tareas con ventanas de tiempo, ajustar rango de b√∫squeda
    const tasksWithWindows = tasks.filter(t => t.windowStart && t.windowEnd);
    if (tasksWithWindows.length > 0) {
        const earliestWindow = new Date(Math.min(...tasksWithWindows.map(t => new Date(t.windowStart))));
        const latestWindow = new Date(Math.max(...tasksWithWindows.map(t => new Date(t.windowEnd))));

        searchStart = earliestWindow > today ? earliestWindow : today;
        searchEnd = latestWindow;
    }

    if (totalDuration <= availableHours) {
        // Generar d√≠as candidatos dentro del rango de b√∫squeda
        const candidates = [];
        let currentDay = new Date(searchStart);

        while (currentDay <= searchEnd) {
            // Verificar si todas las tareas pueden agendarse en este d√≠a
            const dateStr = formatDateToString(currentDay);
            const isValidForAll = tasks.every(task => {
                // Si la tarea tiene ventana, verificar que este d√≠a est√© dentro
                if (task.windowStart && task.windowEnd) {
                    const windowStart = new Date(task.windowStart);
                    const windowEnd = new Date(task.windowEnd);
                    windowStart.setHours(0, 0, 0, 0);
                    windowEnd.setHours(0, 0, 0, 0);

                    return currentDay >= windowStart && currentDay <= windowEnd;
                }
                return true;
            });

            if (isValidForAll) {
                const tasksThisDay = state.tasks.filter(t => t.assignedDate === dateStr).length;
                candidates.push({ day: new Date(currentDay), count: tasksThisDay });
            }

            currentDay.setDate(currentDay.getDate() + 1);
        }

        if (candidates.length === 0) {
            // No hay d√≠as v√°lidos, retornar hoy
            return formatDateToString(today);
        }

        // Preferir d√≠as de semana (Lun-Vie)
        const weekdayOptions = candidates.filter(d => {
            const dayOfWeek = d.day.getDay();
            return dayOfWeek >= 1 && dayOfWeek <= 5;
        });

        if (weekdayOptions.length > 0) {
            weekdayOptions.sort((a, b) => a.count - b.count);
            return formatDateToString(weekdayOptions[0].day);
        }

        // Si no hay d√≠as de semana, usar cualquier d√≠a
        candidates.sort((a, b) => a.count - b.count);
        return formatDateToString(candidates[0].day);
    }

    return formatDateToString(today);
}

// Renderizar sugerencias
function renderSuggestions(suggestions) {
    const container = document.getElementById('suggestions');

    if (suggestions.length === 0) {
        container.innerHTML = '<div class="empty-state">No hay sugerencias por el momento</div>';
        return;
    }

    container.innerHTML = suggestions.map(suggestion => `
        <div class="suggestion-item">
            <div class="suggestion-title">
                ${suggestion.type === 'proximity' ? 'üó∫Ô∏è Tareas cercanas' : ''}
                ${suggestion.type === 'location-group' ? 'üìç Agrupar por ubicaci√≥n' : ''}
                ${suggestion.type === 'urgent' ? '‚ö†Ô∏è Tarea urgente' : ''}
                ${suggestion.type === 'deadline' ? '‚è∞ Fecha l√≠mite pr√≥xima' : ''}
            </div>
            <div class="suggestion-reason">${suggestion.reason}</div>
            <div class="suggestion-tasks">
                <strong>Tareas:</strong>
                <ul>
                    ${suggestion.tasks.map(t => `
                        <li>${t.name} (${t.duration}h)${t.address ? ' - ' + t.address : ''}</li>
                    `).join('')}
                </ul>
                <strong>Duraci√≥n total:</strong> ${suggestion.totalDuration.toFixed(2)} horas
            </div>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                ${suggestion.tasks.map(t => `
                    <button class="btn btn-accept" onclick="assignTask(${t.id}, '${suggestion.day}')">
                        Asignar "${t.name}"
                    </button>
                `).join('')}
            </div>
        </div>
    `).join('');
}

// Renderizar tareas
function renderTasks() {
    const unassigned = state.tasks.filter(t => !t.assignedDate);
    const unassignedContainer = document.getElementById('unassignedTasks');

    if (unassigned.length === 0) {
        unassignedContainer.innerHTML = '<div class="empty-state">Todas las tareas est√°n asignadas</div>';
    } else {
        unassignedContainer.innerHTML = unassigned.map(task => createTaskCard(task)).join('');
    }

    const allTasksContainer = document.getElementById('allTasks');

    if (state.tasks.length === 0) {
        allTasksContainer.innerHTML = '<div class="empty-state">No hay tareas creadas</div>';
    } else {
        const sortedTasks = [...state.tasks].sort((a, b) => {
            const priorityOrder = { urgente: 0, alta: 1, media: 2, baja: 3 };
            return priorityOrder[a.priority] - priorityOrder[b.priority];
        });

        allTasksContainer.innerHTML = sortedTasks.map(task => createTaskCard(task, true)).join('');
    }
}

// Crear tarjeta de tarea
function createTaskCard(task, showAll = false) {
    const deadlineText = task.deadline ?
        `<div>üìÖ L√≠mite: ${formatDate(task.deadline)}</div>` : '';

    const windowText = task.windowStart && task.windowEnd ?
        `<div>üóìÔ∏è Ventana: ${formatDate(task.windowStart)} al ${formatDate(task.windowEnd)}</div>` : '';

    const assignedText = task.assignedDate ?
        `<div>‚úÖ Asignada: ${formatDate(task.assignedDate)} a las ${task.assignedTime}</div>` : '';

    const addressText = task.address ?
        `<div>üó∫Ô∏è Direcci√≥n: ${task.address}</div>` : '';

    const distanceText = getTaskDistanceInfo(task);

    const priorityClass = `priority-${task.priority}`;

    return `
        <div class="task-item ${priorityClass}">
            <div class="task-header">
                <div class="task-title">${task.name}</div>
                <div class="task-priority ${priorityClass}">${task.priority}</div>
            </div>
            <div class="task-details">
                <div>‚è±Ô∏è Duraci√≥n: ${task.duration} hora(s)</div>
                <div>üìç Ubicaci√≥n: ${task.location}</div>
                ${addressText}
                ${distanceText}
                ${windowText}
                ${deadlineText}
                ${assignedText}
            </div>
            <div class="task-actions">
                ${!task.assignedDate && !showAll ? `
                    <button class="btn btn-accept" onclick="assignTaskPrompt(${task.id})">Asignar a d√≠a</button>
                ` : ''}
                ${task.assignedDate && showAll ? `
                    <button class="btn btn-secondary" onclick="unassignTask(${task.id})">Desasignar</button>
                ` : ''}
                <button class="btn btn-danger" onclick="deleteTask(${task.id})">Eliminar</button>
            </div>
        </div>
    `;
}

// Obtener informaci√≥n de distancia de una tarea
function getTaskDistanceInfo(task) {
    if (!task.lat || !task.lng) return '';

    const { home, work } = state.locations;
    let html = '<div>';

    if (home.lat && home.lng) {
        const distanceFromHome = calculateDistance(home.lat, home.lng, task.lat, task.lng);
        const travelTime = estimateTravelTime(distanceFromHome);
        html += `üè†‚Üíüìç ${distanceFromHome.toFixed(1)}km (‚âà${travelTime} min) | `;
    }

    if (work.lat && work.lng) {
        const distanceFromWork = calculateDistance(work.lat, work.lng, task.lat, task.lng);
        const travelTime = estimateTravelTime(distanceFromWork);
        html += `üíº‚Üíüìç ${distanceFromWork.toFixed(1)}km (‚âà${travelTime} min)`;
    }

    html += '</div>';
    return html !== '<div></div>' ? html : '';
}

// Prompt para asignar tarea
function assignTaskPrompt(taskId) {
    const task = state.tasks.find(t => t.id === taskId);

    let promptMessage = `Ingresa la fecha para "${task.name}"\nFormato: DD-MM-YYYY (ej: 15-10-2025)`;

    // Si hay ventana de tiempo, mostrarla
    if (task.windowStart && task.windowEnd) {
        promptMessage += `\n\nVentana disponible: ${formatDate(task.windowStart)} al ${formatDate(task.windowEnd)}`;
    }

    const dateInput = prompt(promptMessage);

    if (dateInput) {
        // Convertir DD-MM-YYYY a YYYY-MM-DD
        const isoDate = parseDateInput(dateInput);

        if (!isoDate) {
            alert('Formato inv√°lido. Usa DD-MM-YYYY (ej: 15-10-2025)');
            return;
        }

        // Validar si est√° dentro de la ventana de tiempo
        if (task.windowStart && task.windowEnd) {
            const selectedDate = new Date(isoDate);
            const windowStart = new Date(task.windowStart);
            const windowEnd = new Date(task.windowEnd);

            if (selectedDate < windowStart || selectedDate > windowEnd) {
                const confirmOutside = confirm(
                    `‚ö†Ô∏è La fecha seleccionada est√° fuera de la ventana disponible.\n` +
                    `Ventana: ${formatDate(task.windowStart)} al ${formatDate(task.windowEnd)}\n\n` +
                    `¬øDeseas asignarla de todos modos?`
                );

                if (!confirmOutside) {
                    return;
                }
            }
        }

        assignTask(taskId, isoDate);
    }
}

// Navegaci√≥n de semana
function navigateWeek(direction) {
    const newDate = new Date(state.currentWeekStart);
    newDate.setDate(newDate.getDate() + (direction * 7));
    state.currentWeekStart = newDate;
    renderCalendar();
}

function initializeWeek() {
    const today = new Date();
    const dayOfWeek = today.getDay();
    const diff = today.getDate() - dayOfWeek + (dayOfWeek === 0 ? -6 : 1);
    state.currentWeekStart = new Date(today.setDate(diff));
}

function getWeekDays(startDate) {
    const days = [];
    for (let i = 0; i < 7; i++) {
        const day = new Date(startDate);
        day.setDate(startDate.getDate() + i);
        days.push(day);
    }
    return days;
}

// Renderizar calendario
function renderCalendar() {
    const weekDays = getWeekDays(state.currentWeekStart);
    const calendar = document.getElementById('calendar');
    const weekDisplay = document.getElementById('currentWeek');

    const startStr = formatDateShort(weekDays[0]);
    const endStr = formatDateShort(weekDays[6]);
    weekDisplay.textContent = `${startStr} - ${endStr}`;

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    calendar.innerHTML = weekDays.map(day => {
        const dateStr = formatDateToString(day);
        const dayTasks = state.tasks.filter(t => t.assignedDate === dateStr);
        const isToday = day.getTime() === today.getTime();

        const dayNum = String(day.getDate()).padStart(2, '0');
        const monthNum = String(day.getMonth() + 1).padStart(2, '0');

        return `
            <div class="calendar-day">
                <div class="day-header ${isToday ? 'today' : ''}">
                    ${getDayName(day.getDay())}<br>
                    ${dayNum}-${monthNum}
                </div>
                <div class="day-tasks">
                    <div class="task-block work-block">
                        üíº Trabajo<br>
                        ${state.workSchedule.start} - ${state.workSchedule.end}
                    </div>
                    ${dayTasks.map(task => `
                        <div class="task-block priority-${task.priority}"
                             title="${task.name}\n${task.location}\n${task.duration}h"
                             onclick="unassignTask(${task.id})">
                            ${task.name}<br>
                            ${task.assignedTime} (${task.duration}h)
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }).join('');
}

// Utilidades de tiempo
function parseTime(timeStr) {
    const [hours, minutes] = timeStr.split(':').map(Number);
    return hours * 60 + minutes;
}

function formatMinutesToTime(minutes) {
    const hours = Math.floor(minutes / 60);
    const mins = Math.round(minutes % 60);
    return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
}

// Formato DD-MM-YYYY para mostrar
function formatDate(date) {
    if (typeof date === 'string') {
        date = new Date(date);
    }
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
}

// Formato DD-MM-YYYY abreviado con d√≠a de semana
function formatDateShort(date) {
    if (typeof date === 'string') {
        date = new Date(date);
    }
    const days = ['Dom', 'Lun', 'Mar', 'Mi√©', 'Jue', 'Vie', 'S√°b'];
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    return `${days[date.getDay()]} ${day}-${month}`;
}

// Convertir de DD-MM-YYYY a Date
function parseDateDDMMYYYY(dateStr) {
    const parts = dateStr.split('-');
    if (parts.length === 3) {
        const day = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1;
        const year = parseInt(parts[2]);
        return new Date(year, month, day);
    }
    return null;
}

// Formato ISO para almacenar (YYYY-MM-DD)
function formatDateToString(date) {
    if (typeof date === 'string') {
        date = new Date(date);
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
}

// Convertir de YYYY-MM-DD a DD-MM-YYYY para input
function formatDateForInput(dateStr) {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
}

// Convertir de input DD-MM-YYYY a YYYY-MM-DD para almacenar
function parseDateInput(inputStr) {
    if (!inputStr) return null;
    const parts = inputStr.split('-');
    if (parts.length === 3) {
        const day = parts[0].padStart(2, '0');
        const month = parts[1].padStart(2, '0');
        const year = parts[2];
        return `${year}-${month}-${day}`;
    }
    return null;
}

function getDayName(dayNum) {
    const days = ['Domingo', 'Lunes', 'Martes', 'Mi√©rcoles', 'Jueves', 'Viernes', 'S√°bado'];
    return days[dayNum];
}

// Almacenamiento
function saveToStorage() {
    localStorage.setItem('calendarApp', JSON.stringify(state));
}

function loadFromStorage() {
    const saved = localStorage.getItem('calendarApp');
    if (saved) {
        const loadedState = JSON.parse(saved);
        state.workSchedule = loadedState.workSchedule || state.workSchedule;
        state.locations = loadedState.locations || state.locations;
        state.tasks = loadedState.tasks || [];

        // Cargar valores en los formularios
        document.getElementById('workStart').value = state.workSchedule.start;
        document.getElementById('workEnd').value = state.workSchedule.end;

        if (state.locations.home.address) {
            document.getElementById('homeAddress').value = state.locations.home.address;
            updateLocationDisplay('home');
        }

        if (state.locations.work.address) {
            document.getElementById('workAddress').value = state.locations.work.address;
            updateLocationDisplay('work');
        }

        if (state.locations.commute.homeToWork) {
            document.getElementById('homeToWork').value = state.locations.commute.homeToWork;
        }

        if (state.locations.commute.workToHome) {
            document.getElementById('workToHome').value = state.locations.commute.workToHome;
        }
    }
}

// Notificaciones
function showNotification(message, type) {
    console.log(`[${type}] ${message}`);
    // Puedes implementar un sistema de toast aqu√≠
}
